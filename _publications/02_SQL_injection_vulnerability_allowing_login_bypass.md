---
title: "02 Write-up: SQL injection vulnerability allowing login bypass"
collection: publications
category: portswigger
permalink: /publications/02_SQL_injection_vulnerability_allowing_login_bypass
excerpt: 'Este laboratorio contiene una vulnerabilidad de inyección SQL en la función de inicio de sesión. Para resolver el laboratorio, realizamos un ataque de inyección SQL que elude la autenticación y nos permite iniciar sesión en la aplicación como usuario administrador.'
date: 2024-12-01
#venue: 'Journal 1'
#slidesurl: 'http://academicpages.github.io/files/slides1.pdf'
#paperurl: 'http://academicpages.github.io/files/paper1.pdf'
citation: 'SQL injection vulnerability allowing login bypass'
---

![logo]({{site.url}}/images/SQLi/sqli-2/logo.png)

Lab-Link: <https://portswigger.net/web-security/sql-injection/lab-login-bypass>  
Dificultad: APPRENTICE  

## Descripción del laboratorio

![Descripción]({{site.url}}/images/SQLi/sqli-2/descripcion.png)

## Query

La consulta utilizada en el laboratorio tendrá un aspecto similar a:

```sql
SELECT * FROM users WHERE username = '<USERNAME>' AND password = '<PASSWORD>'
```

## Pasos

### Evaluar la solicitud

Cuando se utiliza `carlos` como nombre de usuario y `passwrod` como contraseña, el contenido de los datos de la solicitud tiene este aspecto:

![String de la consulta]({{site.url}}/images/SQLi/sqli-2/string_consulta.png)

Al menos uno de los parámetros es vulnerable a la inyección SQL.

### Inyectar en nombre de usuario

Empiezo intentando inyectar el nombre de usuario. Para hacer que la parte WHERE de la consulta devuelva la información del administrador, es necesario evitar la comprobación de la contraseña. Esto se puede hacer inyectando un comentario después del nombre de usuario, haciendo que el servidor ignore el resto de la consulta.

```sql
WHERE username = 'administrator' --
```

El resultado será una consulta del tipo

```sql
SELECT * FROM users WHERE username = 'administrator' -- ' AND password = '<PASSWORD>'
```

Tenga en cuenta que la comilla simple que la aplicación probablemente inserta después del nombre de usuario también se comentará.

![Inyectar nombre de usuario por navegador]({{site.url}}/images/SQLi/sqli-2/usuario_navegador.png)

Los datos de solicitud enviados están codificados con URL. Al introducir la inyección en el navegador, éste lo hará automáticamente. En Burp Suite, esto debe hacerse manualmente (`CTRL-u`)

![Inyectar consulta]({{site.url}}/images/SQLi/sqli-2/inyectar_administrador.png)

Arroja que se aprobo el laboratorio

![Aprobado]({{site.url}}/images/SQLi/sqli-2/aprobado.png)

### Inyección en campo de Password

También puedo intentar inyectar la contraseña. La cláusula WHERE fallará, ya que no conozco la contraseña. Pero si asumo (o sé) que el nombre de columna del nombre de usuario es en realidad `username`, entonces puedo simplemente añadir una segunda condición que tendrá éxito:

```sql
WHERE username = 'xx' AND password = 'yy' or username = 'administrator'
```

La parte inyectada en el campo de contraseña es

```sql
' or username = 'administrator
```

La comilla simple termina el argumento de la contraseña, y el argumento `administrator` termina con la comilla simple que la aplicación inserta después de la contraseña. El método anterior de «comentar todo lo que sigue» también funciona.

Por supuesto, esto sólo funcionará si la contraseña se almacena como texto sin formato. De lo contrario, el SQL insertado simplemente se codificará y nunca llegará a la base de datos.

Como el campo de contraseña no muestra la entrada, es más conveniente introducirla directamente en Burp Suite Repeater. El contenido del campo `username` será ignorado.

![Inyectar en password]({{site.url}}/images/SQLi/sqli-2/sqli_password.png)

Esto también da lugar al acceso a la cuenta `administrator`.

![Inyectar sqli password]({{site.url}}/images/SQLi/sqli-2/string_password.png)

Arroja que se aprobo el laboratorio

![Aprobado]({{site.url}}/images/SQLi/sqli-2/aprobado.png)
