# Write-up: SQL injection vulnerability allowing login bypass

![logo]({{site.url}}/images/SQLi/sqli-2/logo.png)

Este artículo sobre el laboratorio "SQL injection vulnerability allowing login bypass" forma parte de mi serie de tutoriales para [PortSwigger's Web Security Academy](https://portswigger.net/web-security).

Lab-Link: <https://portswigger.net/web-security/sql-injection/lab-login-bypass>  
Dificultad: APPRENTICE  

## Descripción del laboratorio

![lab_description]({{site.url}}/images/SQLi/sqli-2/lab_description.png)

## Query

La consulta utilizada en el laboratorio tendrá un aspecto similar a

```sql
SELECT * FROM users WHERE username = '<USERNAME>' AND password = '<PASSWORD>'
```

## Pasos

### Evaluar la solicitud

When using `administrator` as username and `xxx` as password, the data content of the request looks like this:

![data content of request]({{site.url}}/images/SQLi/sqli-2/query_string.png)

At least one of the parameters is vulnerable to SQL injection.

### Inject in username

Empiezo intentando inyectar el nombre de usuario. Para hacer que la parte WHERE de la consulta devuelva la información del administrador, hay que evitar la comprobación de la contraseña. Esto se puede hacer inyectando un comentario después del nombre de usuario, haciendo que el servidor ignore el resto de la consulta.

```sql
WHERE username = 'administrator' --
```

El resultado será una consulta del tipo

```sql
SELECT * FROM users WHERE username = 'administrator' -- ' AND password = '<PASSWORD>'
```

Tenga en cuenta que la comilla simple que la aplicación probablemente inserta después del nombre de usuario también se comentará.

![inject username in the browser]({{site.url}}/images/SQLi/sqli-2/inject_in_username_browser.png)

Los datos de solicitud enviados están codificados con URL. Al introducir la inyección en el navegador, éste lo hará automáticamente. En Burp Suite, esto debe hacerse manualmente (`CTRL-u`)

![inject username request]({{site.url}}/images/SQLi/sqli-2/request_data_username.png)

Y estoy en

![success]({{site.url}}/images/SQLi/sqli-2/success.png)

### Inyectar contraseña

También puedo intentar inyectar la contraseña. La cláusula WHERE fallará, ya que no conozco la contraseña. Pero si asumo (o sé) que el nombre de columna del nombre de usuario es en realidad `username`, entonces puedo simplemente añadir una segunda condición que tendrá éxito:

```sql
WHERE username = 'xx' AND password = 'yy' or username = 'administrator'
```

La parte inyectada en el campo de contraseña es

```sql
' or username = 'administrator
```

La comilla simple termina el argumento de la contraseña, y el argumento `administrator` termina con la comilla simple que la aplicación inserta después de la contraseña. El método anterior de «comentar todo lo que sigue» también funciona.

Por supuesto, esto sólo funcionará si la contraseña se almacena como texto sin formato. De lo contrario, el SQL insertado simplemente se codificará y nunca llegará a la base de datos.

Como el campo de contraseña no muestra la entrada, es más conveniente introducirla directamente en Burp Suite Repeater. El contenido del campo `username` será ignorado.

![inject in password]({{site.url}}/images/SQLi/sqli-2/inject_in_password.png)

Esto también da lugar al acceso a la cuenta `administrator`.

![success]({{site.url}}/images/SQLi/sqli-2/success.png)

Al mismo tiempo, el laboratorio actualiza a

![success_banner]({{site.url}}/images/SQLi/sqli-2/success_banner.png)